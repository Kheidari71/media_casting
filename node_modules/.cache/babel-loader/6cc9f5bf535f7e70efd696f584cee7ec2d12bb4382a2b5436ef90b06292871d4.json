{"ast":null,"code":"\n\n// const express = require('express');\n// const http = require('http');\n// const { Server } = require('socket.io');\n// const path = require('path');\n// const cors = require('cors');\n// const multer = require('multer');\n// const fs = require('fs').promises;\n// const { spawn } = require('child_process');\n\n// // Create Express app and HTTP server\n// const app = express();\n// const server = http.createServer(app);\n\n// // Create upload directory \n// const uploadDir = path.join(__dirname, 'uploads');\n// try {\n//   fs.mkdirSync(uploadDir, { recursive: true });\n// } catch (err) {\n//   console.error('Error creating upload directory:', err);\n// }\n\n// // Configure storage\n// const storage = multer.diskStorage({\n//   destination: function (req, file, cb) {\n//     cb(null, uploadDir);\n//   },\n//   filename: function (req, file, cb) {\n//     // Use a unique filename to avoid conflicts\n//     const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9) + \n//                      path.extname(file.originalname);\n//     cb(null, uniqueName);\n//   }\n// });\n\n// const upload = multer({ storage: storage });\n\n// // Function to process video with FFmpeg\n// async function processVideo(inputPath) {\n//   return new Promise((resolve, reject) => {\n//     const outputPath = inputPath.replace(path.extname(inputPath), '_optimized.mp4');\n\n//     // Comprehensive FFmpeg optimization command\n//     const ffmpegArgs = [\n//       '-i', inputPath,\n//       // Video codec settings\n//       '-c:v', 'libx264',     // Use H.264 codec\n//       '-preset', 'medium',   // Encoding preset (balance between speed and compression)\n//       '-crf', '23',          // Constant Rate Factor (lower means higher quality, 18-28 is good)\n//       '-maxrate', '2M',      // Maximum bitrate\n//       '-bufsize', '4M',      // Rate control buffer\n\n//       // Keyframe settings for better streaming\n//       '-g', '60',            // Keyframe interval (1 keyframe per 2 seconds at 30fps)\n//       '-keyint_min', '30',   // Minimum interval between keyframes\n\n//       // Audio settings\n//       '-c:a', 'aac',         // AAC audio codec\n//       '-b:a', '128k',        // Audio bitrate\n\n//       // Additional optimization flags\n//       '-pix_fmt', 'yuv420p', // Pixel format for wide compatibility\n//       '-movflags', '+faststart', // Optimize for web streaming\n\n//       outputPath\n//     ];\n\n//     // Spawn FFmpeg process\n//     const ffmpeg = spawn('ffmpeg', ffmpegArgs);\n\n//     // Logging for debugging\n//     let errorOutput = '';\n//     ffmpeg.stderr.on('data', (data) => {\n//       errorOutput += data.toString();\n//       console.log(`FFmpeg processing: ${data}`);\n//     });\n\n//     // Handle process completion\n//     ffmpeg.on('close', async (code) => {\n//       if (code === 0) {\n//         try {\n//           // Get file stats to verify processing\n//           const stats = await fs.stat(outputPath);\n//           console.log(`Processed video created: ${outputPath}`);\n//           console.log(`File size: ${stats.size / 1024 / 1024} MB`);\n\n//           // Optional: Remove original file\n//           await fs.unlink(inputPath);\n\n//           resolve(outputPath);\n//         } catch (error) {\n//           console.error('Post-processing error:', error);\n//           resolve(outputPath);\n//         }\n//       } else {\n//         console.error('FFmpeg processing failed');\n//         console.error('Error output:', errorOutput);\n//         reject(new Error(`FFmpeg process exited with code ${code}`));\n//       }\n//     });\n\n//     // Handle spawn errors\n//     ffmpeg.on('error', (error) => {\n//       console.error('FFmpeg spawn error:', error);\n//       reject(error);\n//     });\n//   });\n// }\n\n// // Enable CORS\n// app.use(cors());\n\n// // Serve static files from the build directory\n// app.use(express.static(path.join(__dirname, 'build')));\n\n// // Serve uploaded files with proper streaming support\n// app.use('/media', async (req, res, next) => {\n//   try {\n//     const filePath = path.join(uploadDir, req.url);\n\n//     // Check if file exists\n//     try {\n//       await fs.access(filePath);\n//     } catch (err) {\n//       return res.status(404).send('File not found');\n//     }\n\n//     const stat = await fs.stat(filePath);\n//     const fileSize = stat.size;\n//     const range = req.headers.range;\n\n//     // Determine content type based on file extension\n//     const ext = path.extname(filePath).toLowerCase();\n//     const contentTypeMap = {\n//       '.mp4': 'video/mp4',\n//       '.mov': 'video/quicktime',\n//       '.webm': 'video/webm',\n//       '.jpg': 'image/jpeg',\n//       '.jpeg': 'image/jpeg',\n//       '.png': 'image/png',\n//       '.gif': 'image/gif'\n//     };\n\n//     const contentType = contentTypeMap[ext] || 'application/octet-stream';\n\n//     if (range && ['video/mp4', 'video/quicktime', 'video/webm'].includes(contentType)) {\n//       const parts = range.replace(/bytes=/, \"\").split(\"-\");\n//       const start = parseInt(parts[0], 10);\n//       const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;\n//       const chunksize = (end - start) + 1;\n//       const file = fs.createReadStream(filePath, {start, end});\n\n//       res.writeHead(206, {\n//         'Content-Range': `bytes ${start}-${end}/${fileSize}`,\n//         'Accept-Ranges': 'bytes',\n//         'Content-Length': chunksize,\n//         'Content-Type': contentType,\n//         'Cache-Control': 'public, max-age=86400', // 24-hour caching\n//       });\n\n//       file.pipe(res);\n//     } else {\n//       res.writeHead(200, {\n//         'Content-Length': fileSize,\n//         'Content-Type': contentType,\n//         'Accept-Ranges': 'bytes',\n//         'Cache-Control': 'public, max-age=86400',\n//       });\n//       fs.createReadStream(filePath).pipe(res);\n//     }\n//   } catch (err) {\n//     console.error('Error serving media:', err);\n//     next(err);\n//   }\n// });\n\n// // Handle file uploads with video processing\n// app.post('/upload', upload.single('file'), async (req, res) => {\n//   if (!req.file) {\n//     return res.status(400).send('No file uploaded');\n//   }\n\n//   try {\n//     // Define video file extensions\n//     const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.wmv'];\n//     const fileExt = path.extname(req.file.filename).toLowerCase();\n\n//     let fileUrl;\n//     // Process video files\n//     if (videoExtensions.includes(fileExt)) {\n//       try {\n//         // Process the video\n//         const processedFilePath = await processVideo(req.file.path);\n\n//         // Get the processed filename\n//         const processedFileName = path.basename(processedFilePath);\n\n//         // Construct file URL (adjust IP/port as needed)\n//         fileUrl = `http://192.168.0.161:5000/media/${processedFileName}`;\n\n//         res.json({ \n//           url: fileUrl, \n//           message: 'Video processed successfully for optimal streaming' \n//         });\n//       } catch (processingError) {\n//         console.error('Video processing error:', processingError);\n\n//         // Fallback: use original file if processing fails\n//         const fallbackUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n//         res.json({ \n//           url: fallbackUrl, \n//           message: 'Video processing failed. Using original file.' \n//         });\n//       }\n//     } else {\n//       // Non-video files: proceed with normal upload\n//       fileUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n//       res.json({ url: fileUrl });\n//     }\n//   } catch (error) {\n//     console.error('Upload processing error:', error);\n//     res.status(500).send('Error processing upload');\n//   }\n// });\n\n// // The rest of your existing Socket.IO and server code remains the same\n// // (Socket.io connection handler, etc.)\n\n// // Create Socket.io server with CORS configuration\n// const io = new Server(server, {\n//   cors: {\n//     origin: \"*\", // Allow all origins in development\n//     methods: [\"GET\", \"POST\"]\n//   }\n// });\n\n// // Your existing Socket.IO connection handlers and other server logic \n// // (I'll omit for brevity, as they remain unchanged from your original code)\n\n// // Socket.io connection handler remains the same as in your original code...\n// io.on('connection', (socket) => {\n//   // ... (existing socket connection handling code)\n// });\n\n// // Start the server\n// const PORT = process.env.PORT || 5000;\n// server.listen(PORT, '0.0.0.0', () => {\n//     console.log(`Server listening on port ${PORT}`);\n// });","map":{"version":3,"names":[],"sources":["/Users/developmentsigncast.ca/Desktop/caster-final/src/components/Player/Player.jsx"],"sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n// const express = require('express');\n// const http = require('http');\n// const { Server } = require('socket.io');\n// const path = require('path');\n// const cors = require('cors');\n// const multer = require('multer');\n// const fs = require('fs').promises;\n// const { spawn } = require('child_process');\n\n// // Create Express app and HTTP server\n// const app = express();\n// const server = http.createServer(app);\n\n// // Create upload directory \n// const uploadDir = path.join(__dirname, 'uploads');\n// try {\n//   fs.mkdirSync(uploadDir, { recursive: true });\n// } catch (err) {\n//   console.error('Error creating upload directory:', err);\n// }\n\n// // Configure storage\n// const storage = multer.diskStorage({\n//   destination: function (req, file, cb) {\n//     cb(null, uploadDir);\n//   },\n//   filename: function (req, file, cb) {\n//     // Use a unique filename to avoid conflicts\n//     const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9) + \n//                      path.extname(file.originalname);\n//     cb(null, uniqueName);\n//   }\n// });\n\n// const upload = multer({ storage: storage });\n\n// // Function to process video with FFmpeg\n// async function processVideo(inputPath) {\n//   return new Promise((resolve, reject) => {\n//     const outputPath = inputPath.replace(path.extname(inputPath), '_optimized.mp4');\n    \n//     // Comprehensive FFmpeg optimization command\n//     const ffmpegArgs = [\n//       '-i', inputPath,\n//       // Video codec settings\n//       '-c:v', 'libx264',     // Use H.264 codec\n//       '-preset', 'medium',   // Encoding preset (balance between speed and compression)\n//       '-crf', '23',          // Constant Rate Factor (lower means higher quality, 18-28 is good)\n//       '-maxrate', '2M',      // Maximum bitrate\n//       '-bufsize', '4M',      // Rate control buffer\n      \n//       // Keyframe settings for better streaming\n//       '-g', '60',            // Keyframe interval (1 keyframe per 2 seconds at 30fps)\n//       '-keyint_min', '30',   // Minimum interval between keyframes\n      \n//       // Audio settings\n//       '-c:a', 'aac',         // AAC audio codec\n//       '-b:a', '128k',        // Audio bitrate\n      \n//       // Additional optimization flags\n//       '-pix_fmt', 'yuv420p', // Pixel format for wide compatibility\n//       '-movflags', '+faststart', // Optimize for web streaming\n      \n//       outputPath\n//     ];\n\n//     // Spawn FFmpeg process\n//     const ffmpeg = spawn('ffmpeg', ffmpegArgs);\n\n//     // Logging for debugging\n//     let errorOutput = '';\n//     ffmpeg.stderr.on('data', (data) => {\n//       errorOutput += data.toString();\n//       console.log(`FFmpeg processing: ${data}`);\n//     });\n\n//     // Handle process completion\n//     ffmpeg.on('close', async (code) => {\n//       if (code === 0) {\n//         try {\n//           // Get file stats to verify processing\n//           const stats = await fs.stat(outputPath);\n//           console.log(`Processed video created: ${outputPath}`);\n//           console.log(`File size: ${stats.size / 1024 / 1024} MB`);\n\n//           // Optional: Remove original file\n//           await fs.unlink(inputPath);\n          \n//           resolve(outputPath);\n//         } catch (error) {\n//           console.error('Post-processing error:', error);\n//           resolve(outputPath);\n//         }\n//       } else {\n//         console.error('FFmpeg processing failed');\n//         console.error('Error output:', errorOutput);\n//         reject(new Error(`FFmpeg process exited with code ${code}`));\n//       }\n//     });\n\n//     // Handle spawn errors\n//     ffmpeg.on('error', (error) => {\n//       console.error('FFmpeg spawn error:', error);\n//       reject(error);\n//     });\n//   });\n// }\n\n// // Enable CORS\n// app.use(cors());\n\n// // Serve static files from the build directory\n// app.use(express.static(path.join(__dirname, 'build')));\n\n// // Serve uploaded files with proper streaming support\n// app.use('/media', async (req, res, next) => {\n//   try {\n//     const filePath = path.join(uploadDir, req.url);\n    \n//     // Check if file exists\n//     try {\n//       await fs.access(filePath);\n//     } catch (err) {\n//       return res.status(404).send('File not found');\n//     }\n    \n//     const stat = await fs.stat(filePath);\n//     const fileSize = stat.size;\n//     const range = req.headers.range;\n    \n//     // Determine content type based on file extension\n//     const ext = path.extname(filePath).toLowerCase();\n//     const contentTypeMap = {\n//       '.mp4': 'video/mp4',\n//       '.mov': 'video/quicktime',\n//       '.webm': 'video/webm',\n//       '.jpg': 'image/jpeg',\n//       '.jpeg': 'image/jpeg',\n//       '.png': 'image/png',\n//       '.gif': 'image/gif'\n//     };\n    \n//     const contentType = contentTypeMap[ext] || 'application/octet-stream';\n    \n//     if (range && ['video/mp4', 'video/quicktime', 'video/webm'].includes(contentType)) {\n//       const parts = range.replace(/bytes=/, \"\").split(\"-\");\n//       const start = parseInt(parts[0], 10);\n//       const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;\n//       const chunksize = (end - start) + 1;\n//       const file = fs.createReadStream(filePath, {start, end});\n      \n//       res.writeHead(206, {\n//         'Content-Range': `bytes ${start}-${end}/${fileSize}`,\n//         'Accept-Ranges': 'bytes',\n//         'Content-Length': chunksize,\n//         'Content-Type': contentType,\n//         'Cache-Control': 'public, max-age=86400', // 24-hour caching\n//       });\n      \n//       file.pipe(res);\n//     } else {\n//       res.writeHead(200, {\n//         'Content-Length': fileSize,\n//         'Content-Type': contentType,\n//         'Accept-Ranges': 'bytes',\n//         'Cache-Control': 'public, max-age=86400',\n//       });\n//       fs.createReadStream(filePath).pipe(res);\n//     }\n//   } catch (err) {\n//     console.error('Error serving media:', err);\n//     next(err);\n//   }\n// });\n\n// // Handle file uploads with video processing\n// app.post('/upload', upload.single('file'), async (req, res) => {\n//   if (!req.file) {\n//     return res.status(400).send('No file uploaded');\n//   }\n\n//   try {\n//     // Define video file extensions\n//     const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.wmv'];\n//     const fileExt = path.extname(req.file.filename).toLowerCase();\n\n//     let fileUrl;\n//     // Process video files\n//     if (videoExtensions.includes(fileExt)) {\n//       try {\n//         // Process the video\n//         const processedFilePath = await processVideo(req.file.path);\n        \n//         // Get the processed filename\n//         const processedFileName = path.basename(processedFilePath);\n        \n//         // Construct file URL (adjust IP/port as needed)\n//         fileUrl = `http://192.168.0.161:5000/media/${processedFileName}`;\n        \n//         res.json({ \n//           url: fileUrl, \n//           message: 'Video processed successfully for optimal streaming' \n//         });\n//       } catch (processingError) {\n//         console.error('Video processing error:', processingError);\n        \n//         // Fallback: use original file if processing fails\n//         const fallbackUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n//         res.json({ \n//           url: fallbackUrl, \n//           message: 'Video processing failed. Using original file.' \n//         });\n//       }\n//     } else {\n//       // Non-video files: proceed with normal upload\n//       fileUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n//       res.json({ url: fileUrl });\n//     }\n//   } catch (error) {\n//     console.error('Upload processing error:', error);\n//     res.status(500).send('Error processing upload');\n//   }\n// });\n\n// // The rest of your existing Socket.IO and server code remains the same\n// // (Socket.io connection handler, etc.)\n\n// // Create Socket.io server with CORS configuration\n// const io = new Server(server, {\n//   cors: {\n//     origin: \"*\", // Allow all origins in development\n//     methods: [\"GET\", \"POST\"]\n//   }\n// });\n\n// // Your existing Socket.IO connection handlers and other server logic \n// // (I'll omit for brevity, as they remain unchanged from your original code)\n\n// // Socket.io connection handler remains the same as in your original code...\n// io.on('connection', (socket) => {\n//   // ... (existing socket connection handling code)\n// });\n\n// // Start the server\n// const PORT = process.env.PORT || 5000;\n// server.listen(PORT, '0.0.0.0', () => {\n//     console.log(`Server listening on port ${PORT}`);\n// });"],"mappings":";;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}