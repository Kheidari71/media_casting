{"ast":null,"code":"const express = require('express');\nconst http = require('http');\nconst {\n  Server\n} = require('socket.io');\nconst path = require('path');\nconst cors = require('cors');\nconst multer = require('multer');\nconst fs = require('fs').promises;\nconst {\n  spawn\n} = require('child_process');\n\n// Create Express app and HTTP server\nconst app = express();\nconst server = http.createServer(app);\n\n// Create upload directory \nconst uploadDir = path.join(__dirname, 'uploads');\ntry {\n  fs.mkdirSync(uploadDir, {\n    recursive: true\n  });\n} catch (err) {\n  console.error('Error creating upload directory:', err);\n}\n\n// Configure storage\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, uploadDir);\n  },\n  filename: function (req, file, cb) {\n    // Use a unique filename to avoid conflicts\n    const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9) + path.extname(file.originalname);\n    cb(null, uniqueName);\n  }\n});\nconst upload = multer({\n  storage: storage\n});\n\n// Function to process video with FFmpeg\nasync function processVideo(inputPath) {\n  return new Promise((resolve, reject) => {\n    const outputPath = inputPath.replace(path.extname(inputPath), '_optimized.mp4');\n\n    // Comprehensive FFmpeg optimization command\n    const ffmpegArgs = ['-i', inputPath,\n    // Video codec settings\n    '-c:v', 'libx264',\n    // Use H.264 codec\n    '-preset', 'medium',\n    // Encoding preset (balance between speed and compression)\n    '-crf', '23',\n    // Constant Rate Factor (lower means higher quality, 18-28 is good)\n    '-maxrate', '2M',\n    // Maximum bitrate\n    '-bufsize', '4M',\n    // Rate control buffer\n\n    // Keyframe settings for better streaming\n    '-g', '60',\n    // Keyframe interval (1 keyframe per 2 seconds at 30fps)\n    '-keyint_min', '30',\n    // Minimum interval between keyframes\n\n    // Audio settings\n    '-c:a', 'aac',\n    // AAC audio codec\n    '-b:a', '128k',\n    // Audio bitrate\n\n    // Additional optimization flags\n    '-pix_fmt', 'yuv420p',\n    // Pixel format for wide compatibility\n    '-movflags', '+faststart',\n    // Optimize for web streaming\n\n    outputPath];\n\n    // Spawn FFmpeg process\n    const ffmpeg = spawn('ffmpeg', ffmpegArgs);\n\n    // Logging for debugging\n    let errorOutput = '';\n    ffmpeg.stderr.on('data', data => {\n      errorOutput += data.toString();\n      console.log(`FFmpeg processing: ${data}`);\n    });\n\n    // Handle process completion\n    ffmpeg.on('close', async code => {\n      if (code === 0) {\n        try {\n          // Get file stats to verify processing\n          const stats = await fs.stat(outputPath);\n          console.log(`Processed video created: ${outputPath}`);\n          console.log(`File size: ${stats.size / 1024 / 1024} MB`);\n\n          // Optional: Remove original file\n          await fs.unlink(inputPath);\n          resolve(outputPath);\n        } catch (error) {\n          console.error('Post-processing error:', error);\n          resolve(outputPath);\n        }\n      } else {\n        console.error('FFmpeg processing failed');\n        console.error('Error output:', errorOutput);\n        reject(new Error(`FFmpeg process exited with code ${code}`));\n      }\n    });\n\n    // Handle spawn errors\n    ffmpeg.on('error', error => {\n      console.error('FFmpeg spawn error:', error);\n      reject(error);\n    });\n  });\n}\n\n// Enable CORS\napp.use(cors());\n\n// Serve static files from the build directory\napp.use(express.static(path.join(__dirname, 'build')));\n\n// Serve uploaded files with proper streaming support\napp.use('/media', async (req, res, next) => {\n  try {\n    const filePath = path.join(uploadDir, req.url);\n\n    // Check if file exists\n    try {\n      await fs.access(filePath);\n    } catch (err) {\n      return res.status(404).send('File not found');\n    }\n    const stat = await fs.stat(filePath);\n    const fileSize = stat.size;\n    const range = req.headers.range;\n\n    // Determine content type based on file extension\n    const ext = path.extname(filePath).toLowerCase();\n    const contentTypeMap = {\n      '.mp4': 'video/mp4',\n      '.mov': 'video/quicktime',\n      '.webm': 'video/webm',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.png': 'image/png',\n      '.gif': 'image/gif'\n    };\n    const contentType = contentTypeMap[ext] || 'application/octet-stream';\n    if (range && ['video/mp4', 'video/quicktime', 'video/webm'].includes(contentType)) {\n      const parts = range.replace(/bytes=/, \"\").split(\"-\");\n      const start = parseInt(parts[0], 10);\n      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;\n      const chunksize = end - start + 1;\n      const file = fs.createReadStream(filePath, {\n        start,\n        end\n      });\n      res.writeHead(206, {\n        'Content-Range': `bytes ${start}-${end}/${fileSize}`,\n        'Accept-Ranges': 'bytes',\n        'Content-Length': chunksize,\n        'Content-Type': contentType,\n        'Cache-Control': 'public, max-age=86400' // 24-hour caching\n      });\n      file.pipe(res);\n    } else {\n      res.writeHead(200, {\n        'Content-Length': fileSize,\n        'Content-Type': contentType,\n        'Accept-Ranges': 'bytes',\n        'Cache-Control': 'public, max-age=86400'\n      });\n      fs.createReadStream(filePath).pipe(res);\n    }\n  } catch (err) {\n    console.error('Error serving media:', err);\n    next(err);\n  }\n});\n\n// Handle file uploads with video processing\napp.post('/upload', upload.single('file'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded');\n  }\n  try {\n    // Define video file extensions\n    const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.wmv'];\n    const fileExt = path.extname(req.file.filename).toLowerCase();\n    let fileUrl;\n    // Process video files\n    if (videoExtensions.includes(fileExt)) {\n      try {\n        // Process the video\n        const processedFilePath = await processVideo(req.file.path);\n\n        // Get the processed filename\n        const processedFileName = path.basename(processedFilePath);\n\n        // Construct file URL (adjust IP/port as needed)\n        fileUrl = `http://192.168.0.161:5000/media/${processedFileName}`;\n        res.json({\n          url: fileUrl,\n          message: 'Video processed successfully for optimal streaming'\n        });\n      } catch (processingError) {\n        console.error('Video processing error:', processingError);\n\n        // Fallback: use original file if processing fails\n        const fallbackUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n        res.json({\n          url: fallbackUrl,\n          message: 'Video processing failed. Using original file.'\n        });\n      }\n    } else {\n      // Non-video files: proceed with normal upload\n      fileUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n      res.json({\n        url: fileUrl\n      });\n    }\n  } catch (error) {\n    console.error('Upload processing error:', error);\n    res.status(500).send('Error processing upload');\n  }\n});\n\n// The rest of your existing Socket.IO and server code remains the same\n// (Socket.io connection handler, etc.)\n\n// Create Socket.io server with CORS configuration\nconst io = new Server(server, {\n  cors: {\n    origin: \"*\",\n    // Allow all origins in development\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\n// Your existing Socket.IO connection handlers and other server logic \n// (I'll omit for brevity, as they remain unchanged from your original code)\n\n// Socket.io connection handler remains the same as in your original code...\nio.on('connection', socket => {\n  // ... (existing socket connection handling code)\n});\n\n// Start the server\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, '0.0.0.0', () => {\n  console.log(`Server listening on port ${PORT}`);\n});","map":{"version":3,"names":["express","require","http","Server","path","cors","multer","fs","promises","spawn","app","server","createServer","uploadDir","join","__dirname","mkdirSync","recursive","err","console","error","storage","diskStorage","destination","req","file","cb","filename","uniqueName","Date","now","Math","round","random","extname","originalname","upload","processVideo","inputPath","Promise","resolve","reject","outputPath","replace","ffmpegArgs","ffmpeg","errorOutput","stderr","on","data","toString","log","code","stats","stat","size","unlink","Error","use","static","res","next","filePath","url","access","status","send","fileSize","range","headers","ext","toLowerCase","contentTypeMap","contentType","includes","parts","split","start","parseInt","end","chunksize","createReadStream","writeHead","pipe","post","single","videoExtensions","fileExt","fileUrl","processedFilePath","processedFileName","basename","json","message","processingError","fallbackUrl","io","origin","methods","socket","PORT","process","env","listen"],"sources":["/Users/developmentsigncast.ca/Desktop/caster-final/src/components/Player/Player.jsx"],"sourcesContent":["const express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\nconst path = require('path');\nconst cors = require('cors');\nconst multer = require('multer');\nconst fs = require('fs').promises;\nconst { spawn } = require('child_process');\n\n// Create Express app and HTTP server\nconst app = express();\nconst server = http.createServer(app);\n\n// Create upload directory \nconst uploadDir = path.join(__dirname, 'uploads');\ntry {\n  fs.mkdirSync(uploadDir, { recursive: true });\n} catch (err) {\n  console.error('Error creating upload directory:', err);\n}\n\n// Configure storage\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, uploadDir);\n  },\n  filename: function (req, file, cb) {\n    // Use a unique filename to avoid conflicts\n    const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9) + \n                     path.extname(file.originalname);\n    cb(null, uniqueName);\n  }\n});\n\nconst upload = multer({ storage: storage });\n\n// Function to process video with FFmpeg\nasync function processVideo(inputPath) {\n  return new Promise((resolve, reject) => {\n    const outputPath = inputPath.replace(path.extname(inputPath), '_optimized.mp4');\n    \n    // Comprehensive FFmpeg optimization command\n    const ffmpegArgs = [\n      '-i', inputPath,\n      // Video codec settings\n      '-c:v', 'libx264',     // Use H.264 codec\n      '-preset', 'medium',   // Encoding preset (balance between speed and compression)\n      '-crf', '23',          // Constant Rate Factor (lower means higher quality, 18-28 is good)\n      '-maxrate', '2M',      // Maximum bitrate\n      '-bufsize', '4M',      // Rate control buffer\n      \n      // Keyframe settings for better streaming\n      '-g', '60',            // Keyframe interval (1 keyframe per 2 seconds at 30fps)\n      '-keyint_min', '30',   // Minimum interval between keyframes\n      \n      // Audio settings\n      '-c:a', 'aac',         // AAC audio codec\n      '-b:a', '128k',        // Audio bitrate\n      \n      // Additional optimization flags\n      '-pix_fmt', 'yuv420p', // Pixel format for wide compatibility\n      '-movflags', '+faststart', // Optimize for web streaming\n      \n      outputPath\n    ];\n\n    // Spawn FFmpeg process\n    const ffmpeg = spawn('ffmpeg', ffmpegArgs);\n\n    // Logging for debugging\n    let errorOutput = '';\n    ffmpeg.stderr.on('data', (data) => {\n      errorOutput += data.toString();\n      console.log(`FFmpeg processing: ${data}`);\n    });\n\n    // Handle process completion\n    ffmpeg.on('close', async (code) => {\n      if (code === 0) {\n        try {\n          // Get file stats to verify processing\n          const stats = await fs.stat(outputPath);\n          console.log(`Processed video created: ${outputPath}`);\n          console.log(`File size: ${stats.size / 1024 / 1024} MB`);\n\n          // Optional: Remove original file\n          await fs.unlink(inputPath);\n          \n          resolve(outputPath);\n        } catch (error) {\n          console.error('Post-processing error:', error);\n          resolve(outputPath);\n        }\n      } else {\n        console.error('FFmpeg processing failed');\n        console.error('Error output:', errorOutput);\n        reject(new Error(`FFmpeg process exited with code ${code}`));\n      }\n    });\n\n    // Handle spawn errors\n    ffmpeg.on('error', (error) => {\n      console.error('FFmpeg spawn error:', error);\n      reject(error);\n    });\n  });\n}\n\n// Enable CORS\napp.use(cors());\n\n// Serve static files from the build directory\napp.use(express.static(path.join(__dirname, 'build')));\n\n// Serve uploaded files with proper streaming support\napp.use('/media', async (req, res, next) => {\n  try {\n    const filePath = path.join(uploadDir, req.url);\n    \n    // Check if file exists\n    try {\n      await fs.access(filePath);\n    } catch (err) {\n      return res.status(404).send('File not found');\n    }\n    \n    const stat = await fs.stat(filePath);\n    const fileSize = stat.size;\n    const range = req.headers.range;\n    \n    // Determine content type based on file extension\n    const ext = path.extname(filePath).toLowerCase();\n    const contentTypeMap = {\n      '.mp4': 'video/mp4',\n      '.mov': 'video/quicktime',\n      '.webm': 'video/webm',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.png': 'image/png',\n      '.gif': 'image/gif'\n    };\n    \n    const contentType = contentTypeMap[ext] || 'application/octet-stream';\n    \n    if (range && ['video/mp4', 'video/quicktime', 'video/webm'].includes(contentType)) {\n      const parts = range.replace(/bytes=/, \"\").split(\"-\");\n      const start = parseInt(parts[0], 10);\n      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;\n      const chunksize = (end - start) + 1;\n      const file = fs.createReadStream(filePath, {start, end});\n      \n      res.writeHead(206, {\n        'Content-Range': `bytes ${start}-${end}/${fileSize}`,\n        'Accept-Ranges': 'bytes',\n        'Content-Length': chunksize,\n        'Content-Type': contentType,\n        'Cache-Control': 'public, max-age=86400', // 24-hour caching\n      });\n      \n      file.pipe(res);\n    } else {\n      res.writeHead(200, {\n        'Content-Length': fileSize,\n        'Content-Type': contentType,\n        'Accept-Ranges': 'bytes',\n        'Cache-Control': 'public, max-age=86400',\n      });\n      fs.createReadStream(filePath).pipe(res);\n    }\n  } catch (err) {\n    console.error('Error serving media:', err);\n    next(err);\n  }\n});\n\n// Handle file uploads with video processing\napp.post('/upload', upload.single('file'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded');\n  }\n\n  try {\n    // Define video file extensions\n    const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.wmv'];\n    const fileExt = path.extname(req.file.filename).toLowerCase();\n\n    let fileUrl;\n    // Process video files\n    if (videoExtensions.includes(fileExt)) {\n      try {\n        // Process the video\n        const processedFilePath = await processVideo(req.file.path);\n        \n        // Get the processed filename\n        const processedFileName = path.basename(processedFilePath);\n        \n        // Construct file URL (adjust IP/port as needed)\n        fileUrl = `http://192.168.0.161:5000/media/${processedFileName}`;\n        \n        res.json({ \n          url: fileUrl, \n          message: 'Video processed successfully for optimal streaming' \n        });\n      } catch (processingError) {\n        console.error('Video processing error:', processingError);\n        \n        // Fallback: use original file if processing fails\n        const fallbackUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n        res.json({ \n          url: fallbackUrl, \n          message: 'Video processing failed. Using original file.' \n        });\n      }\n    } else {\n      // Non-video files: proceed with normal upload\n      fileUrl = `http://192.168.0.161:5000/media/${req.file.filename}`;\n      res.json({ url: fileUrl });\n    }\n  } catch (error) {\n    console.error('Upload processing error:', error);\n    res.status(500).send('Error processing upload');\n  }\n});\n\n// The rest of your existing Socket.IO and server code remains the same\n// (Socket.io connection handler, etc.)\n\n// Create Socket.io server with CORS configuration\nconst io = new Server(server, {\n  cors: {\n    origin: \"*\", // Allow all origins in development\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\n// Your existing Socket.IO connection handlers and other server logic \n// (I'll omit for brevity, as they remain unchanged from your original code)\n\n// Socket.io connection handler remains the same as in your original code...\nio.on('connection', (socket) => {\n  // ... (existing socket connection handling code)\n});\n\n// Start the server\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, '0.0.0.0', () => {\n    console.log(`Server listening on port ${PORT}`);\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}